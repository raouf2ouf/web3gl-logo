<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Cork Tech – GSAP Canvas Logo Particles</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <style>
            :root {
                color-scheme: dark;
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #050608;
                color: #fff;
                font-family:
                    system-ui,
                    -apple-system,
                    BlinkMacSystemFont,
                    "SF Pro Text",
                    "Segoe UI",
                    sans-serif;
            }

            .logo-shell {
                width: min(420px, 80vw);
                aspect-ratio: 1 / 1;
                display: flex;
                align-items: center;
                justify-content: center;
                overflow: visible;
                will-change: transform;
            }

            #logo-particles {
                position: relative;
                width: 100%;
                height: 100%;
            }

            #logo-particles canvas {
                width: 100%;
                height: auto;
                aspect-ratio: 1 / 1;
                display: block;
            }
        </style>
    </head>
    <body>
        <div class="logo-shell">
            <div id="logo-particles"></div>
        </div>

        <!-- GSAP core -->
        <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>

        <script>
            (function () {
                const CONTAINER_ID = "logo-particles";
                const LOGICAL_SIZE = 640; // internal canvas coordinate system
                const PARTICLE_COUNT = 2400;
                const MASK_SRC = "cork-tech-logo.svg"; // must live next to this HTML

                // Sampling & visual config
                const PIXEL_STEP = 4;
                const FLOAT_AMPLITUDE = 10; // more noticeable idle float
                const FLOAT_DURATION_MIN = 2.5; // slightly faster drift
                const FLOAT_DURATION_VAR = 3.5;
                const DOT_SIZE_MIN = 1;
                const DOT_SIZE_MAX = 3;
                const DOT_COLOR = "rgba(135, 202, 122, 0.85)"; // Cork green glow
                const OPACITY_MIN = 0.4;
                const OPACITY_MAX = 1.0;

                // Hover “bubble” config (soft)
                const BUBBLE_RADIUS = 100;
                const BUBBLE_SIZE_MULT = 1.0;
                const BUBBLE_OPACITY_BOOST = 0.25;
                const BUBBLE_EASING = 0.1;

                // Parallax (move whole logo-shell)
                const PARALLAX_STRENGTH = 40;
                const PARALLAX_EASING = 0.12;

                // Slow shape drift of the silhouette – more movement at rest
                const SHAPE_DRIFT_AMPLITUDE = 6;

                // Mouse-flow (direction-based movement)
                const FLOW_INTENSITY = 0.12;
                const FLOW_DECAY = 0.93;
                const FLOW_MAX = 12;
                const FLOW_STEP_MAX = 8;

                // Global breathing state for the shell
                const shellTransformState = { scale: 1, rotate: 0 };

                const prefersReducedMotion =
                    window.matchMedia &&
                    window.matchMedia("(prefers-reduced-motion: reduce)")
                        .matches;

                const container = document.getElementById(CONTAINER_ID);
                if (!container) return;

                const shell = container.closest(".logo-shell") || container;

                const canvas = document.createElement("canvas");
                container.appendChild(canvas);
                const ctx = canvas.getContext("2d");

                let dpr = window.devicePixelRatio || 1;

                function resizeCanvas() {
                    dpr = window.devicePixelRatio || 1;
                    canvas.width = LOGICAL_SIZE * dpr;
                    canvas.height = LOGICAL_SIZE * dpr;
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }

                resizeCanvas();
                window.addEventListener("resize", resizeCanvas);

                const particles = [];
                let pointer = { x: null, y: null };
                let parallax = { x: 0, y: 0 };
                let targetParallax = { x: 0, y: 0 };

                // Mouse-flow state
                let flow = { x: 0, y: 0 };
                let lastMouse = { x: null, y: null };

                // ─────────────────────────────
                // Load SVG mask and sample points
                // ─────────────────────────────
                function loadMaskAndInit() {
                    const img = new Image();
                    img.src = MASK_SRC;
                    img.crossOrigin = "anonymous";

                    img.onload = () => {
                        const maskCanvas = document.createElement("canvas");
                        maskCanvas.width = LOGICAL_SIZE;
                        maskCanvas.height = LOGICAL_SIZE;
                        const maskCtx = maskCanvas.getContext("2d");

                        const scale = Math.min(
                            LOGICAL_SIZE / img.width,
                            LOGICAL_SIZE / img.height,
                        );
                        const drawW = img.width * scale;
                        const drawH = img.height * scale;
                        const offsetX = (LOGICAL_SIZE - drawW) / 2;
                        const offsetY = (LOGICAL_SIZE - drawH) / 2;

                        maskCtx.clearRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
                        maskCtx.drawImage(img, offsetX, offsetY, drawW, drawH);

                        const imageData = maskCtx.getImageData(
                            0,
                            0,
                            LOGICAL_SIZE,
                            LOGICAL_SIZE,
                        );
                        const data = imageData.data;

                        const maskPoints = [];
                        for (let y = 0; y < LOGICAL_SIZE; y += PIXEL_STEP) {
                            for (let x = 0; x < LOGICAL_SIZE; x += PIXEL_STEP) {
                                const idx = (y * LOGICAL_SIZE + x) * 4;
                                const alpha = data[idx + 3];
                                if (alpha > 128) {
                                    maskPoints.push({ x, y });
                                }
                            }
                        }

                        if (!maskPoints.length) return;

                        for (let i = 0; i < PARTICLE_COUNT; i++) {
                            const p =
                                maskPoints[
                                    Math.floor(
                                        Math.random() * maskPoints.length,
                                    )
                                ];
                            const size =
                                DOT_SIZE_MIN +
                                Math.random() * (DOT_SIZE_MAX - DOT_SIZE_MIN);
                            const baseOpacity =
                                OPACITY_MIN +
                                Math.random() * (OPACITY_MAX - OPACITY_MIN);

                            particles.push({
                                homeX: p.x,
                                homeY: p.y,
                                homeOffsetX: 0,
                                homeOffsetY: 0,
                                offsetX: 0,
                                offsetY: 0,
                                size,
                                baseSize: size,
                                baseOpacity,
                                opacity: baseOpacity,
                                bubbleFactor: 0,
                                bubbleTarget: 0,
                                flowFactor: 0.5 + Math.random() * 0.5,
                            });
                        }

                        initTweens();
                        initInteractivity();
                        gsap.ticker.add(render);
                    };
                }

                // ─────────────────────────────
                // GSAP tweens: float, flicker, drift, breathing
                // ─────────────────────────────
                function initTweens() {
                    if (prefersReducedMotion) {
                        particles.forEach((p) => {
                            gsap.to(p, {
                                opacity: p.baseOpacity,
                                duration: 2,
                                repeat: -1,
                                yoyo: true,
                                ease: "sine.inOut",
                            });
                        });
                        return;
                    }

                    particles.forEach((p) => {
                        // noticeable idle float
                        gsap.to(p, {
                            offsetX: `random(-${FLOAT_AMPLITUDE}, ${FLOAT_AMPLITUDE})`,
                            offsetY: `random(-${FLOAT_AMPLITUDE}, ${FLOAT_AMPLITUDE})`,
                            duration:
                                FLOAT_DURATION_MIN +
                                Math.random() * FLOAT_DURATION_VAR,
                            repeat: -1,
                            yoyo: true,
                            ease: "sine.inOut",
                        });

                        // Gentle size + opacity breathing
                        gsap.to(p, {
                            size: () =>
                                p.baseSize * (0.9 + Math.random() * 0.2),
                            opacity: () =>
                                OPACITY_MIN +
                                Math.random() *
                                    (OPACITY_MAX - OPACITY_MAX * 0.3),
                            duration: 3 + Math.random() * 2,
                            repeat: -1,
                            yoyo: true,
                            ease: "sine.inOut",
                        });

                        // Stronger silhouette drift – more “alive” at rest
                        gsap.to(p, {
                            homeOffsetX: `random(-${SHAPE_DRIFT_AMPLITUDE}, ${SHAPE_DRIFT_AMPLITUDE})`,
                            homeOffsetY: `random(-${SHAPE_DRIFT_AMPLITUDE}, ${SHAPE_DRIFT_AMPLITUDE})`,
                            duration: 8 + Math.random() * 10,
                            repeat: -1,
                            yoyo: true,
                            ease: "sine.inOut",
                        });
                    });

                    gsap.to(shellTransformState, {
                        scale: 1.02,
                        duration: 7,
                        repeat: -1,
                        yoyo: true,
                        ease: "sine.inOut",
                    });

                    gsap.to(shellTransformState, {
                        rotate: 2.5,
                        duration: 11,
                        repeat: -1,
                        yoyo: true,
                        ease: "sine.inOut",
                    });
                }

                // ─────────────────────────────
                // Hover bubble + parallax + mouse-flow (with clamped steps)
                // ─────────────────────────────
                function initInteractivity() {
                    document.addEventListener("mousemove", (e) => {
                        const rect = canvas.getBoundingClientRect();
                        const nx =
                            ((e.clientX - rect.left) / rect.width) *
                            LOGICAL_SIZE;
                        const ny =
                            ((e.clientY - rect.top) / rect.height) *
                            LOGICAL_SIZE;
                        pointer.x = nx;
                        pointer.y = ny;

                        const vpX = e.clientX / window.innerWidth - 0.5;
                        const vpY = e.clientY / window.innerHeight - 0.5;
                        targetParallax.x = vpX * PARALLAX_STRENGTH;
                        targetParallax.y = vpY * PARALLAX_STRENGTH;

                        if (lastMouse.x != null && lastMouse.y != null) {
                            let dx = e.clientX - lastMouse.x;
                            let dy = e.clientY - lastMouse.y;

                            const scaleX = LOGICAL_SIZE / rect.width;
                            const scaleY = LOGICAL_SIZE / rect.height;

                            let stepX = dx * scaleX;
                            let stepY = dy * scaleY;

                            const stepMag = Math.hypot(stepX, stepY);
                            if (stepMag > FLOW_STEP_MAX) {
                                const s = FLOW_STEP_MAX / stepMag;
                                stepX *= s;
                                stepY *= s;
                            }

                            flow.x += stepX * FLOW_INTENSITY;
                            flow.y += stepY * FLOW_INTENSITY;

                            const mag = Math.hypot(flow.x, flow.y);
                            if (mag > FLOW_MAX) {
                                const s = FLOW_MAX / mag;
                                flow.x *= s;
                                flow.y *= s;
                            }
                        }

                        lastMouse.x = e.clientX;
                        lastMouse.y = e.clientY;
                    });

                    document.addEventListener("mouseleave", () => {
                        pointer.x = null;
                        pointer.y = null;
                        targetParallax.x = 0;
                        targetParallax.y = 0;
                        lastMouse.x = null;
                        lastMouse.y = null;
                    });
                }

                // ─────────────────────────────
                // Render loop
                // ─────────────────────────────
                function render() {
                    if (!particles.length) return;

                    parallax.x +=
                        (targetParallax.x - parallax.x) * PARALLAX_EASING;
                    parallax.y +=
                        (targetParallax.y - parallax.y) * PARALLAX_EASING;

                    flow.x *= FLOW_DECAY;
                    flow.y *= FLOW_DECAY;

                    shell.style.transform =
                        `translate3d(${parallax.x}px, ${parallax.y}px, 0) ` +
                        `rotate(${shellTransformState.rotate}deg) ` +
                        `scale(${shellTransformState.scale})`;

                    ctx.clearRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
                    ctx.fillStyle = DOT_COLOR;

                    for (const p of particles) {
                        const baseX = p.homeX + p.homeOffsetX + p.offsetX;
                        const baseY = p.homeY + p.homeOffsetY + p.offsetY;

                        const flowX = flow.x * p.flowFactor;
                        const flowY = flow.y * p.flowFactor;

                        const flowXPos = baseX + flowX;
                        const flowYPos = baseY + flowY;

                        if (
                            pointer.x != null &&
                            pointer.y != null &&
                            !prefersReducedMotion
                        ) {
                            const dx = flowXPos - pointer.x;
                            const dy = flowYPos - pointer.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            let influence = 0;
                            if (dist < BUBBLE_RADIUS) {
                                influence = 1 - dist / BUBBLE_RADIUS;
                            }
                            p.bubbleTarget = influence;
                        } else {
                            p.bubbleTarget = 0;
                        }

                        p.bubbleFactor +=
                            (p.bubbleTarget - p.bubbleFactor) * BUBBLE_EASING;

                        const x = flowXPos;
                        const y = flowYPos;
                        const size =
                            p.size * (1 + BUBBLE_SIZE_MULT * p.bubbleFactor);
                        const opacity = Math.min(
                            1,
                            p.opacity + BUBBLE_OPACITY_BOOST * p.bubbleFactor,
                        );

                        ctx.globalAlpha = opacity;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.globalAlpha = 1;
                }

                loadMaskAndInit();
            })();
        </script>
    </body>
</html>
